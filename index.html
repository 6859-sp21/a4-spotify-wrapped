<!DOCTYPE html>
<meta charset="utf-8">
<script src="https://d3js.org/d3.v6.js"></script>
<script src="https://d3js.org/d3-scale-chromatic.v1.min.js"></script>
    <!-- Boostrap -->
    <link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.1.3/css/bootstrap.min.css">
    <script src="https://ajax.googleapis.com/ajax/libs/jquery/3.5.1/jquery.min.js"></script>
    <script src="https://maxcdn.bootstrapcdn.com/bootstrap/3.4.1/js/bootstrap.min.js"></script>

<html>
  <style>
    body, p {
      font: 15px helvetica;
    }

    #chart {
      background: white;
    }


  </style>
    <head>
      <h1>Spotify: The Beatles Acousticness and Danceability</h1>
    </head>
  <body class="container-fluid">


    <div id="hit-or-flop">
      <h2>Guess if the song was a hit or a flop!</h3>
      <p>A song is a "hit" if it appeared in Billboards Hot-100 tracks in the decade</p>
      <h3>Current song: <span id="song-title"></span></h3>
      <!-- <div id="song-search-box" class='input-group input-group-lg'>
        <input type="text" id="song-search" >
      </div> -->
      <div id="song-search-box"  class="input-group input-group-lg">
        <input type="text" class="form-control" aria-label="Large" placeholder="Search for a song">
      </div>

      <h4 style="margin-top: 5px">Your Guess:
        <button type="button" id="hit" class="btn btn-success" onClick="isHit(true)">Hit</button>
        <button type="button" id="flop" class="btn btn-danger" onClick="isHit(false)">Flop</button>
      </h4>
      <div id="result"></div>
      <button type="button" id="next" class="btn btn-primary" style="margin-bottom: 5px;">Next Song</button>
      <!-- next step: If result is not empty, show "New Song" button for generating another new song? Or just always have a new song button available so users can skip if they want -->


    </div>
    <div id="chart"></div>
    <div id="circularBarplot"></div>

    <p><strong>References: </strong></p>
    <a href="https://www.kaggle.com/yamaerenay/spotify-dataset-19212020-160k-tracks">Dataset</a><br>
    <a href="https://www.d3-graph-gallery.com/graph/streamgraph_template.html">Streamgraph Template</a><br>
    <a href="https://www.d3-graph-gallery.com/graph/stackedarea_template.html">Stacked Area Template</a><br>
    <a href="https://www.d3-graph-gallery.com/graph/line_select.html">Dropdown Template</a> <br>
    <a href="https://github.com/d3/d3-scale-chromatic/blob/master/README.md">Color Scheme</a> <br>
    <br>
  </body>
  <script src="js/hit_flop.js"></script>
  <script>



// trying to get tooltips to work
      d3.csv("merged_datasets.csv", d3.autoType).then(function(data){

        var nextSongElement = document.getElementById('next')
          nextSongElement.addEventListener('click', () => {
            getRandomSong(data)
          })
        console.log(data)

        var song = getRandomSong(data)
        console.log(song)

        songTitles = data.map(d => d.name)
        console.log(songTitles)
        // makeCircularBarplot(song)
        

        //todo: autocomplete input box

        // Select artists-lists made and get artists
        // var dropDown = d3.select("#artists-list").append("select")
        //           .attr("name", "artists");

        // var artist_data = [ {'value': "Elvis Presley"}, {'value': "The Rolling Stones"}, {'value': "The Beatles"}, {'value': "Queen"}, {'value': "Ignacio Corsini"} ]
        // var defaultArtist = artist_data[0].value;

        // let filteredData = filterByArtist(data, defaultArtist)
        // console.log(filteredData)

        // var options = dropDown.selectAll("option")
        //        .data(artist_data)
        //        .enter()
        //        .append("option");

        // options.text(function (d) { return d.value; })
        //        .attr("value", function (d) { return d.value; });
        
        // function click(d) {

        //     if (active === d) return reset();
        //     g.selectAll(".active").classed("active", false);
        //     d3.select("#" + d.properties.artists).classed("active", active = d); // changed selection to id

        //     var b = path.bounds(d);

        //     g.transition().duration(1000).attr("transform",
        //         "translate(" + projection.translate() + ")"
        //         + "scale(" + .95 / Math.max((b[1][0] - b[0][0]) / w, (b[1][1] - b[0][1]) / h) + ")"
        //         + "translate(" + -(b[1][0] + b[0][0]) / 2 + "," + -(b[1][1] + b[0][1]) / 2 + ")");
        // }

        // function menuChanged() {

        //     var selectedValue = event.target.value;  
        //     filteredData = filterByArtist(data, selectedValue)
        //     console.log(filteredData)

        //     svg.selectAll("g")
        //       .data(d3.extent(filteredData, d => d.release_date))
        //       .join(
        //         enter => enter.append("g"),
        //         update => update,
        //         exit => exit.remove()
        //       )

            // data.forEach(function (d) { 
            //     // console.log("Selected value:", selectedValue)
            //     // console.log("This is d:", d)
            //     // console.log(JSON.parse(d.artists).value)

            //     // console.log("PRINTING:", d.artists.substring(2, d.artists.length - 2))

            //     if (selectedValue === d.artists.substring(2, d.artists.length - 2)) {
            //         console.log(selectedValue)
            //         // alert(selectedValue)

            //         // click(d);
                // };
            // })
        // }

        // dropDown.on("change", menuChanged);

//         var keys = data.columns.slice(1,3)

//         var x = d3.scaleUtc()
//           .domain(d3.extent(data, d => d.release_date))
//           .range([margin.left, width - margin.right]);
          
//         var xAxis = svg.append("g")
//           .attr("transform", `translate(0,${height - margin.bottom})`)
//           .call(d3.axisBottom(x).ticks(width / 50).tickSizeOuter(0))
//           .select(".domain").remove()

//         // Customization
//         svg.selectAll(".tick line").attr("stroke", "#b8b8b8")

//         // svg.append("text")
//         //   .attr("text-anchor", "end")
//         //   .attr("x", width)
//         //   .attr("y", height-30 )
//         //   .text("Time (year)");

//         var y = d3.scaleLinear()
//           .domain([0,1])
//           .range([height - margin.bottom, margin.top])

//         svg.append("g")
//           .call(d3.axisLeft(y).ticks(5))

//         var color = d3.scaleOrdinal()
//           .domain(keys)
//           .range(d3.schemeDark2)  

//         var series = d3.stack(['danceability', 'acousticness'])
//           .keys(keys) 
//           .offset(d3.stackOffsetSilhouette) 
//           .order(d3.stackOrderInsideOut) 
//           (data)

//         var Tooltip = svg
//           .append("text")
//           .attr("x", 0)
//           .attr("y", 0)
//           .style("opacity", 0)
//           .style("font-size", 17)
        
//         var mouseover = function(d) {
//           Tooltip.style("opacity", 1)
//           d3.selectAll(".myArea").style("opacity", .2)
//           d3.select(this)
//             .style("stroke", "black")
//             .style("opacity", 1)
//           }

//         var mousemove = function(d,i) {
//           grp = d.target.__data__.key
//           Tooltip.text(grp)
//         }

//         var mouseleave = function(d) {
//           Tooltip.style("opacity", 0)
//           d3.selectAll(".myArea").style("opacity", 1).style("stroke", "none")
//         }

//         // Trying to add brushing and clippiing

//         var clip = svg.append("defs").append("svg:clipPath")
//           .attr("id", "clip")
//           .append("svg:rect")
//           .attr("width", width )
//           .attr("height", height )
//           .attr("x", 0)
//           .attr("y", 0);


//                 // Add brushing
//   var brush = d3.brushX()                 // Add the brush feature using the d3.brush function
//       .extent( [ [0,0], [width,height] ] ) // initialise the brush area: start at 0,0 and finishes at width,height: it means I select the whole graph area
//       .on("end", updateChart) // Each time the brush selection changes, trigger the 'updateChart' function


//   // Create the scatter variable: where both the circles and the brush take place
//   var areaChart = svg.append('g')
//     .attr("clip-path", "url(#clip)")

//     var area = d3.area()
//           .x(d => x(d.data.release_date))
//           .y0(d => y(d[0] - d[0]))
//           .y1(d => y(d[1] - d[0]))  
//           .curve(d3.curveMonotoneX);

//           areaChart
//           .selectAll("mylayers")
//           .data(series)
//           .enter()
//             .append("path")
//             .attr("class", function(d) { return "myArea " + d.key })
//             .style("fill", function(d) { return color(d.key); })
//             .attr("d", area)

//   // // Add the brushing
//   areaChart
//     .append("g")
//       .attr("class", "brush")
//       .call(brush);

//       var idleTimeout
//   function idled() { idleTimeout = null; }

//   // A function that update the chart for given boundaries
//   function updateChart(event, d) {
//     extent = event.selection

//     // If no selection, back to initial coordinate. Otherwise, update X axis domain
//     if(!extent){
//       if (!idleTimeout) return idleTimeout = setTimeout(idled, 350); // This allows to wait a little bit
//       x.domain(d3.extent(data, function(d) { return d.release_date; }))
//     }else{
//       x.domain([ x.invert(extent[0]), x.invert(extent[1]) ])
//       areaChart.select(".brush").call(brush.move, null) // This remove the grey brush area as soon as the selection has been done
//     }

//     // Update axis and area position
//     xAxis.transition().duration(1000).call(d3.axisBottom(x).ticks(10))
//     areaChart
//       .selectAll("path")
//       .transition().duration(1000)
//       .attr("d", area)
//     }

//   //   //////////
//   //   // HIGHLIGHT GROUP //
//   //   //////////

//   //   // What to do when one group is hovered
//     var highlight = function(d){
//       console.log(d)
//       // reduce opacity of all groups
//       d3.selectAll(".myArea").style("opacity", .1)
//       // expect the one that is hovered
//       d3.select("."+d).style("opacity", 1)
//     }

//     // And when it is not hovered anymore
//     var noHighlight = function(d){
//       d3.selectAll(".myArea").style("opacity", 1)
//     }

// //uncomment svg if brushing doesn't work
//         // svg
//         //   .selectAll("mylayers")
//         //   .data(series)
//         //   .enter()
//         //   .append("path")
//         //   .attr("class", "myArea")
//         //   .style("fill", function(d) { return color(d.key); })
//         //   .attr("d", area)
//         //   .on("mouseover", mouseover)
//         //   .on("mousemove", mousemove)
//         //   .on("mouseleave", mouseleave)

//     //////////
//     // LEGEND //
//     //////////

//     // Add one dot in the legend for each name.
//     var size = 20
//     svg.selectAll("myrect")
//       .data(keys)
//       .enter()
//       .append("rect")
//         .attr("x", 400)
//         .attr("y", function(d,i){ return 10 + i*(size+5)})
//         .attr("width", size)
//         .attr("height", size)
//         .style("fill", function(d){ return color(d)})
//         .on("mouseover", highlight)
//         .on("mouseleave", noHighlight)

//     // Add one dot in the legend for each name.
//     svg.selectAll("mylabels")
//       .data(keys)
//       .enter()
//       .append("text")
//         .attr("x", 400 + size*1.2)
//         .attr("y", function(d,i){ return 10 + i*(size+5) + (size/2)})
//         .style("fill", function(d){ return color(d)})
//         .text(function(d){ return d})
//         .attr("text-anchor", "left")
//         .style("alignment-baseline", "middle")
//         .on("mouseover", highlight)
//         .on("mouseleave", noHighlight)

        
      })
      .catch(function(error){})

      function makeCircularBarplot(song) {
        console.log('in make circular barplot')
        console.log(song)

        var transformedData = transformSongFeatureData(song, ['acousticness', 'danceability', 'energy', 'instrumentalness', 'liveness', 'speechiness', 'valence'])
        console.log(transformedData)
                  // set the dimensions and margins of the graph
        var margin = {top: 100, right: 0, bottom: 0, left: 0},
            width = 460 - margin.left - margin.right,
            height = 460 - margin.top - margin.bottom,
            innerRadius = 90,
            outerRadius = Math.min(width, height) / 2;   // the outerRadius goes from the middle of the SVG area to the border

        // append the svg object
        var svg = d3.select("#circularBarplot")
          .append("svg")
            .attr("width", width + margin.left + margin.right)
            .attr("height", height + margin.top + margin.bottom)
          .append("g")
            .attr("transform", "translate(" + (width / 2 + margin.left) + "," + (height / 2 + margin.top) + ")");

        // Scales
        var x = d3.scaleBand()
            .range([0, 2 * Math.PI])    // X axis goes from 0 to 2pi = all around the circle. If I stop at 1Pi, it will be around a half circle
            .align(0)                  // This does nothing
            .domain(transformedData.map(function(d) { return d.feature; })); // The domain of the X axis is the list of states.
        var y = d3.scaleRadial()
            .range([innerRadius, outerRadius])   // Domain will be define later.
            .domain([0, 1]); // Domain of Y is from 0 to the max seen in the data

        // Add the bars
        svg.append("g")
          .selectAll("path")
          .data(transformedData)
          .enter()
          .append("path")
            .attr("fill", "#69b3a2")
            .attr("d", d3.arc()     // imagine your doing a part of a donut plot
                .innerRadius(innerRadius)
                .outerRadius(function(d) { return y(d['value']); })
                .startAngle(function(d) { return x(d.feature); })
                .endAngle(function(d) { return x(d.feature) + x.bandwidth(); })
                .padAngle(0.01)
                .padRadius(innerRadius))

        // Add the labels
        svg.append("g")
            .selectAll("g")
            .data(transformedData)
            .enter()
            .append("g")
              .attr("text-anchor", function(d) { return (x(d.feature) + x.bandwidth() / 2 + Math.PI) % (2 * Math.PI) < Math.PI ? "end" : "start"; })
              .attr("transform", function(d) { return "rotate(" + ((x(d.feature) + x.bandwidth() / 2) * 180 / Math.PI - 90) + ")"+"translate(" + (y(d['value'])+10) + ",0)"; })
            .append("text")
              .text(function(d){return(d.feature)})
              .attr("transform", function(d) { return (x(d.feature) + x.bandwidth() / 2 + Math.PI) % (2 * Math.PI) < Math.PI ? "rotate(180)" : "rotate(0)"; })
              .style("font-size", "11px")
              .attr("alignment-baseline", "middle")
      }



function transformSongFeatureData(song, featuresOfInterest) {
  var output = []
  featuresOfInterest.forEach(feature => {
    var dict = {feature: [feature][0], value: [song[feature]][0]}
    output.push(dict)
  })
  return output;
}
// d3.csv("merged_datasets.csv", function (data) {
//   console.log(data)
//   var song = data[0]


  

// });

    </script>
</html>
